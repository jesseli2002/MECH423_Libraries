
=== Basic library ===
- List of useful header files - I have this
- Circular buffer - I have this; it includes detection of underflow & overflow
- Packet parser - I have this. Husayn thinks they could change the packet format (which might happen), but better to have a reference than not, I presume

=== Clock ===
- Clock_init() - Setup all clocks to use DCO at 8 MHz
- Clock_setDivide() - Set clock dividers individually for MCLK, SMCLK, and ACLK, by passing in a valid divider value or an enumeration.
+ Allow configuring the DCO to different frequencies - see DCOFSEL. Not sure if DCORSEL works on the MSP boards, but if it does, allow changing that too. Best to have an enumeration that you can set the frequency to.



=== LED output ===
I have this done already; each of the functions below takes an unsigned char and interprets it as a list of bits, indicating LED1 thru LED8

- Led_init() - Initializes the LEDs, so you can write 0/1 to disable/enable
- Led_enable() - Turns on some LEDs
- Led_disable() - Turns off some LEDs
- Led_set() - Sets the state of some LEDs



=== UART ===

- ISR to receive data, and circular buffer to store the received data
- Uart_begin() - Setup UART at 9600 baud. 
+ Configurable clock that the UART connects to
+ Uart_beginAt() - Setup UART at configurable baud value. Ideally it should follow the algorithm on page 487 of the manual, and read the frequency from the clock system. Alternatively, have the clock frequency be passed in as a parameter.
- Uart_write() - Writes a character to the UART. Make sure to wait for the TX buffer to clear before continuing.
- Uart_writeString() - I have this; this just writes a null-terminated string to the UART.
- Uart_read() - Reads a single character from the UART circular buffer, or -1 if no data is available.
- Uart_hasData() - Returns true if data is available from the circular buffer, false otherwise
+ Write overflow protection - sets a flag if the circular buffer overflows

=== Timer ===
Keep in mind that there's multiple timers - an ideal solution would allow configuring all timers with almost the same code. Try to reuse code where possible; e.g. it might be possible to have a lookup table for which registers to write to for a given timer. It probably makes sense to separate TimerA and TimerB to a certain degree though...

- Configure input clocks and dividers
- Confiugure compare/capture mode and operating parameters
+ Have parameters be available in human-friendly units (supply source clock frequency and desired period or frequency, and have code do the math itself)
- Have an ISR predefined for everything ahead of time, which just set flags/indicate data values, and have some functions that can enable certain ISRs and access the ISR results
+ Allow ISRs to call arbitrary functions, using function pointers - would be useful for e.g. if a question asks you to setup a timer interrupt to do something every x ms

=== ADC === 
- Adc_init() - Initialize the ADC, binding it to a particular clock. Keep the resolution at 10 bits - if you only need 8, it's very easy to fix during the exam. This should also raise pin 2.7 high, to power accelerometer & NTC
+ Have the options to Adc_init be configurable - most relevant might be # of clock cycles for hold & sample, and the number of clock samples to sample for
- Adc_read(pin) - Read the value from a particular analog input. Implementation will need to disable ADC, do config changes, then re-enable the ADC. This should come with some predefined constants for the accelerometer X, Y, Z axes, as well as the NTC.
